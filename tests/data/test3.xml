<?xml version="1.0" encoding="utf-8"?>
<rss
  version="2.0">
  <channel>
    <title>RTUR.NET</title>
    <link>http://localhost/</link>
    <description>This site is all about developing web applications with focus on designing and building open source blogging solutions. Technologies include ASP.NET Core, C#, Angular, JavaScript and more.</description>
    <lastBuildDate>Thu, 09 Apr 2020 16:22:33 -0500</lastBuildDate>
    <item>
      <guid
        isPermaLink="true">http://localhost/posts/the-big-reshuffle</guid>
      <link>http://localhost/posts/the-big-reshuffle</link>
      <category>blogifier</category>
      <title>The Big Reshuffle</title>
      <description>&lt;p&gt;I thought it will take a whole lot more, but it was surprisingly easy. The big restructure I wanted to do for the Blogifier repository took just a couple of days to complete; splitting into multiple repositories, cleaning and making it all work with each other and publishing to Nuget.org as reusable libraries. So now this all exactly as outlined in the diagram.&lt;/p&gt;
&lt;p&gt;&lt;img src="/data/rtur/2020/4/blogifier-full-diagram2.png" alt="data/rtur/2020/4/blogifier-full-diagram2.png" /&gt;&lt;/p&gt;
&lt;p&gt;One of the reasons for this move is to separate rarely changing functionality from user facing front-end that changes all the time. This also incapsulates things that should not be customized/modified into external packages, where it is harder to change and application gets more stable. It is sort of experimental, I don't know if it will prove successful or not, it could change in the future. For example, I quickly realized that having widgets in its own repository simply inconvenient and leads to duplication and time waste with little advantages, and pushed widgets project back into the web application. Good learning experience nevertheless.&lt;/p&gt;
&lt;p&gt;To sum up, Blogifier is a personal blog application written in ASP.NET Core MVC to serve pages quickly and to make theming easy. The admin panel is all Blazor, so it can be maintained and improved pretty easily given Blazor is very productive and fun to work with.&lt;/p&gt;
&lt;p&gt;The Angular version is not going anywhere - it is a SPA CLI solution running on top of REST APIs, it can be useful beyond it current implementation, with React and Mobile been obvious candidates. So it can evolve along with default MVC version. They could get closer down the road, with just a checkbox for a user to select one or the other. Or they could go completely different routes, time will tell. Bottom line, they both loved and supported.&lt;/p&gt;
</description>
      <pubDate>Thu, 09 Apr 2020 16:22:33 -0500</pubDate>
    </item>
    <item>
      <guid
        isPermaLink="true">http://localhost/posts/open-source-project-structure</guid>
      <link>http://localhost/posts/open-source-project-structure</link>
      <category>open source</category>
      <category>blogifier</category>
      <title>Open Source Project Structure</title>
      <description>&lt;h3 id="do-as-the-romans-do"&gt;Do as the Romans do&lt;/h3&gt;
&lt;p&gt;Most open source projects follow common pattern for directory structure which looks somewhat like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;build
dist
samples
src
tests
readme.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes sense and easy to understand - you put your source files under &lt;code&gt;src&lt;/code&gt;, distribution files go to &lt;code&gt;dist&lt;/code&gt;, unit tests under &lt;code&gt;tests&lt;/code&gt;. If you have a build utility it goes under &lt;code&gt;build&lt;/code&gt;, samples take their own place and so on. Nothing wrong with that, so I mostly follow it for Blogifier and ended up with this structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;docs
plugins
    common
src
    app
    core
tests
    core.tests
readme.md
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docs&lt;/code&gt; has documentation in markdown format. I decided against using Github's wiki, because documentation is version specific and keeping it in the wiki would require maintain all the version differences. This way, you pull docs along with source code and, at least in theory, they match.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;plugins&lt;/code&gt; would have any extensions to the core functionality, like custom themes and widgets. The &lt;code&gt;common&lt;/code&gt; project has all the common plugins, to build new developer would add another project here. Resulted DLL could be side-loaded at run time, so down the road it could be pulled from common store or repository.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src&lt;/code&gt; has two projects. One is &lt;code&gt;app&lt;/code&gt; which is web application or blog itself. It is ASP.NET Core application utilizing MVC for the blog features and Razor Pages for admin panel. Distinction is because MVC ideal for manipulating blog routes and plug in on the fly themes and widgets. Razor Pages are great in separating application by features so it can be structured really nicely. Second project here is &lt;code&gt;core&lt;/code&gt; - class library with core back-end functionality (services, data access etc.).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tests&lt;/code&gt; currently has unit tests mostly covering logic in services. If there need for example to have integration testing, the &lt;code&gt;app.tests&lt;/code&gt; project can be added here. Same goes for plugins - you write your plugin - you can add tests for it here, in &lt;code&gt;plugin-name.tests&lt;/code&gt; project.&lt;/p&gt;
&lt;h3 id="solution-folders"&gt;Solution Folders&lt;/h3&gt;
&lt;p&gt;Visual Studio has a feature called &lt;code&gt;solution folders&lt;/code&gt; - whenever you add new project to solution it is added as virtual folder, no physical folder actually added to the file system. At least not where you would expect it. This can be very misleading and, when you switch to file-based editor, like VS Code or Atom, your projects look messed up. To avoid this, I always create physical folder and select it for new project so that virtual and physical match.&lt;/p&gt;
&lt;h3 id="deep-nesting"&gt;Deep nesting&lt;/h3&gt;
&lt;p&gt;Not a fan of deep nesting, that's why &lt;code&gt;tests&lt;/code&gt; and &lt;code&gt;plugins&lt;/code&gt; at top level instead of nesting under &lt;code&gt;src&lt;/code&gt;. Just a personal preference.&lt;/p&gt;
&lt;h3 id="documentation"&gt;Documentation&lt;/h3&gt;
&lt;p&gt;I started by creating wiki pages in Github, but quickly realized this is going to be hard to keep up with changes in every version. So instead of having &lt;code&gt;this only applies for version 1.2.3&lt;/code&gt; statements, all documentation is going into &lt;code&gt;docs&lt;/code&gt; folder and naturally version specific. Just as &lt;code&gt;readme.md&lt;/code&gt; it is all in markdown format.&lt;/p&gt;
&lt;p&gt;Hope this makes sense and easy to follow, if you have better ideas comments are welcome.&lt;/p&gt;
</description>
      <pubDate>Fri, 14 Sep 2018 02:33:34 -0500</pubDate>
    </item>
    <item>
      <guid
        isPermaLink="true">http://localhost/posts/asp.net-core-on-digitalocean-jumpstart</guid>
      <link>http://localhost/posts/asp.net-core-on-digitalocean-jumpstart</link>
      <category>coding</category>
      <category>DigitalOcean</category>
      <title>ASP.NET Core on DigitalOcean Jumpstart</title>
      <description>&lt;p&gt;There is decent amount of documentation on how to install, configure and run .NET Core on Linux, but most of it pretty generic and may be a little overwhelming when you trying to accomplish specific and relatively simple task. So I decided to put this together in case I need to go over it again or maybe someone else can use it. This not by any means an extensive tutorial on how to setup things in production secure environment, it is how to get you started quickly and (relatively) easily so you won't drop it discouraged and frustrated half way through.&lt;/p&gt;
&lt;h3 id="your-digitalocean-account"&gt;Your DigitalOcean account&lt;/h3&gt;
&lt;p&gt;I&amp;quot;m using &lt;a href="https://www.digitalocean.com"&gt;DigitalOcean&lt;/a&gt; here as example, but obviously this can be any Linux based hosting. Get your hosting account, in my case I got cheapest &amp;quot;droplet&amp;quot; available running Ubuntu 18.04 ($5 monthly). Once you'll get this, host should provide info on how to connect to your server remotely, usually using SSH. To make things simpler, I run Linux subsystem on my Windows machine so I can use &amp;quot;Bash on Ubuntu&amp;quot; utility and run SSH command straight from there.&lt;/p&gt;
&lt;h3 id="installing.net-core"&gt;Installing .NET Core&lt;/h3&gt;
&lt;p&gt;Microsoft likes to change links, so this may on may not work, but you can go to &lt;a href="https://www.microsoft.com/net/learn/get-started-with-dotnet-tutorial"&gt;this tutorial&lt;/a&gt;, select your OS and run through it all the way, installing latest version of .NET Core and testing it with &amp;quot;hello world&amp;quot; console application. Make sure you can run it and all works fine.&lt;/p&gt;
&lt;h3 id="installing-sqlite-optionally"&gt;Installing SQLite (optionally)&lt;/h3&gt;
&lt;p&gt;Because my web application requires SQLite database, I'm also installing it here.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;sudo apt-get update
sudo apt-get install sqlite3 libsqlite3-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="testing-your-app-locally"&gt;Testing your app locally&lt;/h3&gt;
&lt;p&gt;Publish your ASP.NET Core application to local folder, so you can run it locally before deployment and verify it works correctly from command line. In Visual Studio, you simply select your app in solution explorer, right-click and publish to folded. When done, open command line terminal (CMD utility) and navigate to that folder. Given my application name is &amp;quot;App&amp;quot; and it compiled into &amp;quot;App.dll&amp;quot; this will look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;dotnet App.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should start application running and you should be able open web browser and navigate to &lt;code&gt;http://localhost:5000&lt;/code&gt;. If your app runs and looks right, congrats - you ready to deploy it to remote host server!&lt;/p&gt;
&lt;h3 id="deployment"&gt;Deployment&lt;/h3&gt;
&lt;p&gt;Filezilla is still the best FTP client for me, but you can use whatever you want - create new folder in your host server, I used &amp;quot;blog&amp;quot;, and copy all files from your local published directory to your server. For ASP.NET Core important thing is, your published directory must include &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;runtimes&lt;/code&gt; folders. So somewhat like this:&lt;/p&gt;
&lt;img src="/data/rtur/2018/9/published-dir.png" alt="published-dir.png" style="width:100%" /&gt;
&lt;p&gt;(you may not have other folders, like &amp;quot;views&amp;quot;, if you choose to pre-compile app on publish, but I personally like to have them)&lt;/p&gt;
&lt;h3 id="testing-remote-app"&gt;Testing remote app&lt;/h3&gt;
&lt;p&gt;Now we want to test remote app just as we did locally, to make sure it works fine on your host server. So back to command line, remote to server and go to your app directory, for me it is &lt;code&gt;cd blog&lt;/code&gt;. Run app:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;dotnet App.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, you should see familiar trace and app should start and run on port &lt;code&gt;5000&lt;/code&gt;. But if you go to web browser and navigate to it using &lt;code&gt;http://&amp;lt;your.ip&amp;gt;:5000&lt;/code&gt; you won't see it - your server is not set for it just yet. So to verify it is really working and serving pages, you can request page locally - open another remote terminal and run this command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;curl http://locahost:5000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you see HTML output in the terminal screen, your app is working properly. It is just not available for outside world yet. Moving on.&lt;/p&gt;
&lt;h3 id="installing-nginx"&gt;Installing Nginx&lt;/h3&gt;
&lt;p&gt;To access our web application we need to run a web server, Nginx is a good candidate for the job. Installing it simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;sudo -s
nginx=stable
add-apt-repository ppa:nginx/$nginx
apt-get update
apt-get install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To verify install:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;nginx start
http://&amp;lt;your.ip.here&amp;gt;/index.nginx-debian.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And you should see welcome screen:&lt;/p&gt;
&lt;p&gt;&lt;img src="/data/rtur/2018/9/nginx.PNG" alt="data/rtur/2018/9/nginx.PNG" /&gt;&lt;/p&gt;
&lt;p&gt;Almost there! Now we need to tell Nginx to run our application. For that, we need to edit configuration file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;nano /etc/nginx/sites-available/default
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The end result for edited file should look similar to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;server {
    listen 80;
    location / {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection keep-alive;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This basically telling Nginx to use your application running on port &lt;code&gt;5000&lt;/code&gt; as web root, and you finally can go in the browser to your server's address (&lt;code&gt;http://&amp;lt;your.ip.here&amp;gt;&lt;/code&gt;) and see application in all glory.&lt;/p&gt;
&lt;h3 id="run-as-a-service"&gt;Run as a Service&lt;/h3&gt;
&lt;p&gt;Now it all works, but starting application from command line every time is annoying at best. To make is start automatically it has to run as Linux service. First thing is to create service - fortunately, this as simple as creating a text file in specific directory.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;cd /etc/systemd/system
sudo nano blog.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This opens up text editor, here is content I used for my blog app:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;[Unit]
Description=Blog Application

[Service]
WorkingDirectory=/root/blog
ExecStart=/usr/bin/dotnet /root/blog/App.dll
Restart=always
RestartSec=10
SyslogIdentifier=blog
User=root
Environment=ASPNETCORE_ENVIRONMENT=Production

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Save this, and now to test whole thing with DigitalOcean I enable service and then just go and reboot:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cmd"&gt;systemctl enable blog.service
reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When server comes live, I should just navigate to my site in web browser and, if all works fine, it'll just load.
That's quick and dirty and this is all for now.&lt;/p&gt;
</description>
      <pubDate>Thu, 06 Sep 2018 02:52:36 -0500</pubDate>
    </item>
  </channel>
</rss>